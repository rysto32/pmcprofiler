// Copyright (c) 2018 Ryan Stone.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

#include <cxxtest/TestSuite.h>

#include "SharedString.h"

#include "MapUtil.h"
#include "ValueTraits/SharedString.h"

#include <stdlib.h>
#include <new>
#include <map>

template <typename T>
struct MallocAllocator
{
	typedef T value_type;
	MallocAllocator() = default;

	T* allocate(size_t n)
	{
		auto p = calloc(n, sizeof(T));
		if (p == NULL)
			throw std::bad_alloc();

		return static_cast<T*>(p);
	}

	void deallocate(T* p, size_t) noexcept
	{
		free(p);
	}
};

typedef std::map<const void *, size_t, std::less<const void *>, MallocAllocator<std::pair<const void * const, size_t>>> AllocMap;

AllocMap ranges;

void * operator new(size_t sz)
{
	void * ptr = malloc(sz);
	if (ptr == NULL)
		throw std::bad_alloc();

	try {
		ranges.insert(std::make_pair(ptr, sz));
	} catch (...) {
		free(ptr);
		throw std::bad_alloc();
	}

	return ptr;
}

void operator delete(void * ptr) noexcept
{
	ranges.erase(ptr);
	free(ptr);
}

template<typename T>
bool IsAllocated(T * t)
{
	auto ptr = static_cast<const void*>(t);
	auto it = LastSmallerThan(ranges, ptr);
	if (it == ranges.end())
		return false;

	return it->first <= ptr && ptr < (static_cast<const char*>(it->first) + it->second);
}

class SharedStringTestSuite : public CxxTest::TestSuite
{
public:
	void TestPointsTo()
	{
		SharedString str("myString");

		TS_ASSERT_EQUALS(str->length(), 8);
		TS_ASSERT(!str->empty());
		TS_ASSERT_EQUALS(str->at(1), 'y');
	}

	void TestDereference()
	{
		std::string origString("anotherString");
		SharedString str(origString);

		TS_ASSERT_EQUALS(origString, *str);

		const std::string & ref = *str;
		TS_ASSERT_EQUALS(ref.find("Str"), 7);
	}

	void TestDefaultConstructor()
	{
		SharedString str;

		TS_ASSERT(str->empty());
		TS_ASSERT(str == "");
	}

	void TestCStringConstructor()
	{
		const char *cstr = "this";
		SharedString str(cstr);

		TS_ASSERT_EQUALS(*str, cstr);
	}

	void TestStdStringConstructor()
	{
		std::string std("standard");
		SharedString str(std);

		TS_ASSERT_EQUALS(*str, std);

		// Ensure that the SharedString has allocated its own memory
		TS_ASSERT_DIFFERS(&*str, &std);
	}

	void TestSharedStringCopyConstructor()
	{
		SharedString orig("origString");
		SharedString newStr(orig);

		TS_ASSERT_EQUALS(orig, newStr);

		// Ensure that we did a shallow copy
		TS_ASSERT_EQUALS(&*orig, &*newStr);

		const auto * origMem = &*orig;

		std::string origStr(*orig);

		// Ensure that modifiying the original doesn't affect the copy
		orig.clear();
		TS_ASSERT(orig->empty());
		TS_ASSERT(!newStr->empty());
		TS_ASSERT_DIFFERS(orig, newStr);
		TS_ASSERT_EQUALS(*newStr, origStr);
		TS_ASSERT(IsAllocated(origMem));
	}

	void TestSharedStringMoveConstructor()
	{
		std::string orig("firstStr");
		SharedString first(orig);
		SharedString second(std::move(first));

		TS_ASSERT_EQUALS(orig, *second);

		first = orig;
		TS_ASSERT_EQUALS(first, second);
	}

	void TestInterning()
	{
		const char *cStr = "a c string";
		std::string std(cStr);
		const char cStrArr[] = "a c string";

		SharedString first(cStr);
		SharedString second(std);

		TS_ASSERT_EQUALS(first, second);
		TS_ASSERT_EQUALS(&*first, &*second);

		SharedString third = cStrArr;
		TS_ASSERT_EQUALS(first, third);
		TS_ASSERT_EQUALS(&*first, &*third);

		const auto * origMem = &*first;

		second = "something else";

		TS_ASSERT_DIFFERS(first, second);
		TS_ASSERT_DIFFERS(&*first, &*second);
		TS_ASSERT(IsAllocated(origMem));

		// Release all references to origMem and assert that it has been
		// freed (note: this is a bit fragile -- we depend on the memory
		// not be reallocated, which is only guaranteed to happen
		// because third is a reference counted copy of second, so we
		// won't allocate more memory when third releases the reference)
		first = "";
		third = second;
		TS_ASSERT(!IsAllocated(origMem));
	}

	void TestCopyAssignment()
	{
		const char *cStr = "frist";
		SharedString first("garbage");
		const std::string * data;

		{
			SharedString second(cStr);
			data = &*second;

			// Use first to ensure the optimizer doesn't get any
			// clever ideas and elides the object.
			TS_ASSERT_DIFFERS(first, second);

			first = second;
			TS_ASSERT_EQUALS(first, second);
			TS_ASSERT_EQUALS(*first, cStr);
			TS_ASSERT_EQUALS(&*first, &*second);
		}

		// Ensure that first is still valid after second was destructed
		TS_ASSERT_EQUALS(*first, cStr);
		TS_ASSERT(IsAllocated(data));
	}

	void TestMoveAssignment()
	{
		const char *cStr = "frist";
		SharedString first("garbage");
		SharedString second;
		const std::string * data;

		{
			SharedString third(cStr);
			second = third;
			data = &*second;

			// Use first to ensure the optimizer doesn't get any
			// clever ideas and elides the object.
			TS_ASSERT_DIFFERS(first, third);

			first = std::move(third);
			TS_ASSERT_EQUALS(first, second);
			TS_ASSERT_EQUALS(*first, cStr);
			TS_ASSERT_EQUALS(&*first, &*second);
		}

		// Ensure that first is still valid after second was destructed
		TS_ASSERT_EQUALS(*first, cStr);
		TS_ASSERT_EQUALS(first, second);
		TS_ASSERT(IsAllocated(data));
	}
};
